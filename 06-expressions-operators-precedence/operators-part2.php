<?php echo '<pre>';

$w = @file('file.txt'); // Оператор @ подавляет сообщения об ошибках. Не рекомендуется использовать

// ОПЕРАТОРЫ ИНКРЕМЕНТА И ДЕКРЕМЕНТА (++ --). Влияют только на числа и строки

$x = 5;
echo $x++;              // Постинкремент возвращает значение $x, затем увеличивает $x на единицу
echo $x--;              // Постдекремент возвращает значение $x, затем уменьшает $x на единицу
echo ++$x;              // Преинкремент увеличивает $x на единицу, затем возвращает значение $x
echo --$x;              // Предекремент уменьшает $x на единицу, затем возвращает значение $x

$y = null;
echo --$y, ++$y;        // Null можно увеличить на 1, но операция декремента на него не повлияет

$abc = 'abc';
echo ++$abc, --$abc;    // Инкремент изменит символы в алфавитном порядке, но декремент на строку не повлияет
echo '<br>';


// ЛОГИЧЕСКИЕ ОПЕРАТОРЫ (&& || ! and or xor). Позволяют комбинировать несколько условий

$a = true; $b = false;
var_dump($a && $b);     // Оператор && вернет true, только если оба операнда true
var_dump($c = '1' && $d = 1); // Другие типы конвертируются в bool

var_dump($a || $b);     // Оператор || вернет true, если хотя бы один операнд true
var_dump(!$a || $b);    // Оператор ! отрицает значение, то есть делает false из true и наоборот
echo '<br>';

// Оператор and это аналог &&, но имеет меньший приоритет, поэтому его следует использовать с осторожностью
$e = $a and $b;               // Сначала сработает оператор =, а после него and. Это приведет к багам
var_dump($e);
echo '<br>';

// PHP может проигнорировать второй операнд, если первого достаточно для выполнения условия
$f = true; $g = false;
var_dump($f || $g);             // $f = true, значит условие выполнено, а $g не будет проверяться

function hi()
{
    echo 'Hi!';
    return false;
}
var_dump($g && hi());           // Функция hi() не будет задействована. Достаточно, что $g = false

// Оператор && имеет более высокий приоритет. Часть выражения слева от || будет false. Все выражение вернет true
var_dump($g && hi() || true);   // Функцию hi() по-прежнему нет необходимости задействовать для проверки


// ОПЕРАТОРЫ ДЛЯ РАБОТЫ С МАССИВАМИ (+ == === != <> !==):

$x = ['a' => 1 , 'b' => 2, 'c' => 3];
$y = ['d' => 4, 'f' => 5, 'g' => 6];
print_r($x + $y);               // Оператор + объединяет массивы. Элементы должны иметь уникальные ключи

$u = ['a' => 10, 'b' => 2];
$w = ['a' => 1, 'с' => 3];
print_r($u + $w);       // Если в массивах повторяются ключи, то вернется только ключ из массива слева от +
print_r($w + $u);

$s = ['a' => '1', 'b' => 2];
$t = ['b' => 2, 'a' => 1];

// Оператор == вернет true, если в массивах одинаковые пары ключ-значение, даже если у них разный порядок
var_dump($s == $t);
var_dump($x != $y);     // != и <> вернут true, если в массиве разные пары ключ-значение

// Оператор === вернет true, если в массивах одинаковые пары ключ-значение И одинаковые типы И тот же порядок
var_dump($s === $t);
var_dump($s !== $t);    // !== вернет true, если в массиве разные пары И/ИЛИ типы И/ИЛИ порядок


// ПОБИТОВЫЕ ОПЕРАТОРЫ (& | ^ ~ << >>):
var_dump($h =6 & $i = 3);
# TODO Вернуться к теме позднее https://www.youtube.com/watch?v=gCVlQdbddXY&t=473s